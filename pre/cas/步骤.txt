1. 找到 D:\xiangxue\source\caslockDemo\caslib\build\classes\java\main\com\zero\caslib

打开powershell
输入 java -version

输入javap -v .\Demo01.class > a.txt


享学课堂的老师请吃饭 
服务员问我们的人数

然后我说 我们享学课堂有六个老师

这个时候Av老师来了
他想了下 我们的桃子老师还没吃饭
问了下服务员现在的吃饭人数是多少
服务员告诉他是6个
 于是Av老师获取的人数是六
 Av老师 请桃子老师过来吃饭 他需要确认下
 
 他就打了个电话给桃子老师，出去打电话确认请啦
 就在这个时候我们分流倜傥的Lance老师来了
 他想起 美丽的阿媛老师还没吃饭
 这个时候 他也问服务员现在吃饭的人数是多少
 服务员告诉他是六个
 然后他想了一想 要加上阿媛小姐姐 所以人数是7个
 
 就在这个时候呢，Lance老师 出去上了个WC
 这个时候 AV老师刚好打完电话 确认我们的桃子老师
 会来吃饭，然后他就告诉我们的服务员吃饭的人数要
 调整为7个
 就在AV老师调整完以后，Lance老师从WC回来啦
 也跟服务员说，我们的人数确认为7人
 
 那么问题来啦 服务员只知道我们享学课堂吃饭的人数
 是7个人
 结果呢我们的老师 + 桃子老师 + 阿媛老师 是8个人
 但是呢 服务员只给了7个人的碗筷
 同学们 在这个过程中 你们觉得是谁错啦
 能不能怪服务员呢
 
 服务员说 我只知道问我多少个人
 1 对应获取字段值
 2. 我文化水平不高 也不知道计算1+1等于多少
 3. 只认你告诉我的数值是多少
 
那么我们还是刚才的示例
进行一个改造
我们确定加餐的流程还是不变
1.
2.
3.
但是变化的点在哪儿呢
是在我们的第三步
怎么变化呢
首先AV老师来了 他问服务员 现在我们几个人
于是服务员告诉他6个人
他用一个旧值old=6
然后他说桃子老师要来 要加一个桃子老师
所以新值就是new=7
然后他有一个旧值 和一个新值
他就会给我们的餐厅服务员赋值
这个赋值 加上一个比较和交换
怎么比较
比如说 我们服务员他现在的值是不是还是6
还是6的话，那么就是可以交换为7
当然啦，同时 AV老师是一个线程
Lance老师也是一个线程
 Lance老师在服务员的值还没改变之前拿到的值是6
 Lance老师对我们美丽的阿媛老师有想法，所以呢
 他就叫上阿媛老师 那么6+1 =7
 于是呢 会跟餐厅服务员的值进行一次比较和交换
 old 刚才是6 现在变成了7 是不相等的
 所以交换不成功
  同学们，想一想，我们Lance老师的交换不成功，怎么办
  这个时候 是不是应该可以采取一种重试机制
  Lance老师重新取下服务员的值
  Lance老师是从哪里跌倒 从哪里爬起
  我又问餐厅服务员现在的人数已经是多少啦
  取出来来是7 那么Lance老师掐指一算 7+1=8
  Ok  这个时候就可以跟服务员进行一次比较和交换啦
  刚才取的是7 现在的值还是7 那么就可以交换成功啦
  
  
CAS：对于内存中的某一个值V，提供一个旧值A和一个新值B。
如果提供的旧值V和A相等就把B写入V。这个过程是原子性的。

因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，
但是如果一个值原来是A，变成了B，又变成了A，
那么使用CAS进行检查时会发现它的值没有发生变化，
但是实际上却变化了。
ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，
每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。  
  
ABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。
当前线程的CAS操作无法分辨当前V值是否发生过变化。
关于ABA问题我想了一个例子：在你非常渴的情况下你发现一个盛满水的杯子，
你一饮而尽。之后再给杯子里重新倒满水。然后你离开，
当杯子的真正主人回来时看到杯子还是盛满水，他当然不知道是否被人喝完重新倒满。
解决这个问题的方案的一个策略是每一次倒水假设有一个自动记录仪记录下，
这样主人回来就可以分辨在她离开后是否发生过重新倒满的情况。
这也是解决ABA问题目前采用的策略。

公平锁 与非公平锁



Snchronzed与Lock（轻量级）锁有什么不同？
关键字 -- JVM底层(c c++) ==== CAS是一样的


认为学并发编程 就学一个锁就够了，
觉得不够。。。

打开招聘网


由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现
在有了下面四种方式：

A线程写volatile变量，随后B线程读这个volatile变量。
A线程写volatile变量，随后B线程用CAS更新这个volatile变量。
A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。
A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。
Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以
原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键
（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器
，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）
。同时，volatile变量的读/写和CAS可以实现线程之间的通信。
把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。
如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：

首先，声明共享变量为volatile；
然后，使用CAS的原子条件更新来实现线程之间的同步；
同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。
AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），
这些concurrent包中的基础类都是使用这种模式来实现的，
而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，
concurrent包的实现示意图如下：


原子性就是指该操作是不可再分的。
java.util.concurrent.atomic中有一组使用无锁算法实现的原子操作类。AtomicInteger、AtomicBoolean、AtomicLong 外还有
AtomicReference 。它们分别封装了对整数、整数数组、长整型、长整型数组和普通对象的多线程安全操作。
这些都是居于CAS算法实现的。CAS即：Compare and Swap,是比较并交换的意思。

CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

非阻塞算法 （nonblocking algorithms）
一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。
现代的CPU提供了特殊的指令，可以自动更新共享数据，而且能够检测到其他线程的干扰，而 compareAndSet() 就用这些代替了锁定。




  
  
















































 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 













