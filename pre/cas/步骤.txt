1. 找到 D:\xiangxue\source\caslockDemo\caslib\build\classes\java\main\com\zero\caslib

打开powershell
输入 java -version

输入javap -v .\Demo01.class > a.txt


享学课堂的老师请吃饭 
服务员问我们的人数

然后我说 我们享学课堂有六个老师

这个时候Av老师来了
他想了下 我们的桃子老师还没吃饭
问了下服务员现在的吃饭人数是多少
服务员告诉他是6个
 于是Av老师获取的人数是六
 Av老师 请桃子老师过来吃饭 他需要确认下
 
 他就打了个电话给桃子老师，出去打电话确认请啦
 就在这个时候我们分流倜傥的Lance老师来了
 他想起 美丽的阿媛老师还没吃饭
 这个时候 他也问服务员现在吃饭的人数是多少
 服务员告诉他是六个
 然后他想了一想 要加上阿媛小姐姐 所以人数是7个
 
 就在这个时候呢，Lance老师 出去上了个WC
 这个时候 AV老师刚好打完电话 确认我们的桃子老师
 会来吃饭，然后他就告诉我们的服务员吃饭的人数要
 调整为7个
 就在AV老师调整完以后，Lance老师从WC回来啦
 也跟服务员说，我们的人数确认为7人
 
 那么问题来啦 服务员只知道我们享学课堂吃饭的人数
 是7个人
 结果呢我们的老师 + 桃子老师 + 阿媛老师 是8个人
 但是呢 服务员只给了7个人的碗筷
 同学们 在这个过程中 你们觉得是谁错啦
 能不能怪服务员呢
 
 服务员说 我只知道问我多少个人
 1 对应获取字段值
 2. 我文化水平不高 也不知道计算1+1等于多少
 3. 只认你告诉我的数值是多少
 
那么我们还是刚才的示例
进行一个改造
我们确定加餐的流程还是不变
1.
2.
3.
但是变化的点在哪儿呢
是在我们的第三步
怎么变化呢
首先AV老师来了 他问服务员 现在我们几个人
于是服务员告诉他6个人
他用一个旧值old=6
然后他说桃子老师要来 要加一个桃子老师
所以新值就是new=7
然后他有一个旧值 和一个新值
他就会给我们的餐厅服务员赋值
这个赋值 加上一个比较和交换
怎么比较
比如说 我们服务员他现在的值是不是还是6
还是6的话，那么就是可以交换为7
当然啦，同时 AV老师是一个线程
Lance老师也是一个线程
 Lance老师在服务员的值还没改变之前拿到的值是6
 Lance老师对我们美丽的阿媛老师有想法，所以呢
 他就叫上阿媛老师 那么6+1 =7
 于是呢 会跟餐厅服务员的值进行一次比较和交换
 old 刚才是6 现在变成了7 是不相等的
 所以交换不成功
  同学们，想一想，我们Lance老师的交换不成功，怎么办
  这个时候 是不是应该可以采取一种重试机制
  Lance老师重新取下服务员的值
  Lance老师是从哪里跌倒 从哪里爬起
  我又问餐厅服务员现在的人数已经是多少啦
  取出来来是7 那么Lance老师掐指一算 7+1=8
  Ok  这个时候就可以跟服务员进行一次比较和交换啦
  刚才取的是7 现在的值还是7 那么就可以交换成功啦
  
  
CAS：对于内存中的某一个值V，提供一个旧值A和一个新值B。
如果提供的旧值V和A相等就把B写入V。这个过程是原子性的。

因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，
但是如果一个值原来是A，变成了B，又变成了A，
那么使用CAS进行检查时会发现它的值没有发生变化，
但是实际上却变化了。
ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，
每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。  
  
ABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。
当前线程的CAS操作无法分辨当前V值是否发生过变化。
关于ABA问题我想了一个例子：在你非常渴的情况下你发现一个盛满水的杯子，
你一饮而尽。之后再给杯子里重新倒满水。然后你离开，
当杯子的真正主人回来时看到杯子还是盛满水，他当然不知道是否被人喝完重新倒满。
解决这个问题的方案的一个策略是每一次倒水假设有一个自动记录仪记录下，
这样主人回来就可以分辨在她离开后是否发生过重新倒满的情况。
这也是解决ABA问题目前采用的策略。

公平锁 与非公平锁



Snchronzed与Lock（轻量级）锁有什么不同？
关键字 -- JVM底层(c c++) ==== CAS是一样的


认为学并发编程 就学一个锁就够了，
觉得不够。。。

打开招聘网


由于java的CAS同时具有 volatile 读和volatile写的内存语义，因此Java线程之间的通信现
在有了下面四种方式：

A线程写volatile变量，随后B线程读这个volatile变量。
A线程写volatile变量，随后B线程用CAS更新这个volatile变量。
A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。
A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。
Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以
原子方式对内存执行读-改-写操作，这是在多处理器中实现同步的关键
（从本质上来说，能够支持原子性读-改-写指令的计算机器，是顺序计算图灵机的异步等价机器
，因此任何现代的多处理器都会去支持某种能对内存执行原子性读-改-写操作的原子指令）
。同时，volatile变量的读/写和CAS可以实现线程之间的通信。
把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。
如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：

首先，声明共享变量为volatile；
然后，使用CAS的原子条件更新来实现线程之间的同步；
同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。
AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），
这些concurrent包中的基础类都是使用这种模式来实现的，
而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，
concurrent包的实现示意图如下：


原子性就是指该操作是不可再分的。
java.util.concurrent.atomic中有一组使用无锁算法实现的原子操作类。AtomicInteger、AtomicBoolean、AtomicLong 外还有
AtomicReference 。它们分别封装了对整数、整数数组、长整型、长整型数组和普通对象的多线程安全操作。
这些都是居于CAS算法实现的。CAS即：Compare and Swap,是比较并交换的意思。

CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

非阻塞算法 （nonblocking algorithms）
一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。
现代的CPU提供了特殊的指令，可以自动更新共享数据，而且能够检测到其他线程的干扰，而 compareAndSet() 就用这些代替了锁定。


.1什么是锁？

      在计算机科学中，锁(lock)或互斥(mutex)是一种同步机制，用于在有许多执行线程的环境中强制对资源的访问限制。锁旨在强制实施互斥排他、并发控制策略。

      锁通常需要硬件支持才能有效实施。这种支持通常采取一个或多个原子指令的形式，如"test-and-set", "fetch-and-add" or "compare-and-swap"”。这些指令允许单个进程测试锁是否空闲，如果空闲，则通过单个原子操作获取锁。

1.2.锁的一个重要属性 粒度 Granularity [grænjʊ‘lærɪtɪ]

在引入锁粒度之前，需要了解关于锁的三个概念：

1、锁开销 lock overhead 锁占用内存空间、 cpu初始化和销毁锁、获取和释放锁的时间。程序使用的锁越多，相应的锁开销越大

2、锁竞争 lock contention 一个进程或线程试图获取另一个进程或线程持有的锁，就会发生锁竞争。锁粒度越小，发生锁竞争的可能性就越小

3、死锁 deadlock 至少两个任务中的每一个都等待另一个任务持有的锁的情况锁粒度是衡量锁保护的数据量大小，通常选择粗粒度的锁(锁的数量少，每个锁保护大量的数据)，在当单进程访问受保护的数据时锁开销小，但是当多个进程同时访问时性能很差。因为增大了锁的竞争。相反，使用细粒度的锁(锁数量多，每个锁保护少量的数据)增加了锁的开销但是减少了锁竞争。例如数据库中，锁的粒度有表锁、页锁、行锁、字段锁、字段的一部分锁

相关术语  Critical Section(临界区)、 Mutex/mutual exclusion(互斥体)、 Semaphore/binary semaphore(信号量)

2.锁的种类

2.1.独享锁/共享锁

独享锁是指该锁一次只能被一个线程所持有。 (ReentrantLock、 Synchronized)

共享锁是指该锁可被多个线程所持有。 (ReadWriteLock)

互斥锁/读写锁

独享锁/共享锁这是广义上的说法，互斥锁/读写锁就分别对应具体的实现。在Java中如ReentrantLock就是互斥锁(独享锁)， ReadWriteLock就是读写锁(共享锁)。 独享锁与共享锁也是通过AQS来实现的

锁升级：读锁到写锁 (不支持)

锁降级：写锁到读锁 (支持)

2.2.读写锁 ReentrantReadWriteLock

低16位代表写锁，高16位代表读锁



2.2.公平锁/非公平锁

公平锁是指多个线程按照申请锁的顺序来获取锁。

非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能会造成饥饿现象。

对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。

对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的控制线程对锁的获取， 所以并没有任何办法使其变成公平锁。



 

2.3.可重入锁

可重入锁又名递归锁，是指同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取

 

 

锁。

ReentrantLock和Synchronized都是可重入锁。可重入锁的一个好处是可一定程度避免死锁


 

 

如上面的代码，如果synchronized不是可重入锁的话，testB就不会被当前线程执行，从而形成死锁。

 

需要注意的是，可重入锁加锁和解锁的次数要相等。



C==0表明未获得锁，Else表示已经获得锁，这时对state加1，相应的，每次释放锁都会对state减1

2.4.乐观锁/悲观锁

乐观锁/悲观锁不是指具体类型的锁，而是看待并发的角度。

悲观锁认为存在很多并发更新操作，采取加锁操作，如果不加锁一定会有问题

乐观锁认为不存在很多的并发更新操作，不需要加锁。数据库中乐观锁的实现一般采用版本号，Java中可使用CAS实现乐观锁。

2.5.分段锁

分段锁是一种锁的设计，并不是一种具体的锁。对于ConcuttentHashMap就是通过分段锁实现高效的并发操作。



2.6.自旋锁

自旋锁是指尝试获取锁的线程不会阻塞，而是采用循环的方式尝试获取锁。好处是减少上下文切换，缺点是一直占用CPU资源。



2.7.偏向锁/轻量级锁/重量级锁

这是jdk1.6中对Synchronized锁做的优化，首先了解下对象头(Mark Word)：

运行时JVM内存布局



Mark Word在不同锁状态下的标志位存储



从jdk1.6开始为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。锁共有四种状态，级别从低到高分别是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。随着竞争情况锁状态逐渐升级、锁可以升级但不能降级。

 

偏向锁的获取和撤销：

HotSpot作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入偏向锁。

线程1检查对象头中的Mark Word中是否存储了线程1，如果没有则CAS操作将Mark Word中的线程ID替换为线程1。此时，锁偏向线程1，后面该线程进入同步块时不需要进行CAS操作，只需要简单的测试一下Mark Word中是否存储指向当前线程的偏向锁，如果成功表明该线程已经获得锁。如果失败，则再需要测试一下Mark Word中偏向锁标识是否设置为1(是否是偏向锁)，如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将偏向锁指向当前线程

  

偏向锁的竞争结果:

根据持有偏向锁的线程是否存活

1.如果不活动，偏向锁撤销到无锁状态，再偏向到其他线程
2.如果线程仍然活着，则升级到轻量级锁

偏向锁在Java6和Java7中默认是开启的，但是在应用程序启动几秒后才激活，如果有必要可以关闭延迟：
-XX:BiasedLockingStartupDelay=0

如果确定应用程序中所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：
-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁。

-XX:BiasedLockingStartupDelay=0 -XX:+TraceBiasedLocking

轻量级锁膨胀：

1.线程在执行同步块之前，JVM会在当前栈桢中创建用于存储锁记录的空间(Lock record)，并将对象头中的Mark Word复制到锁记录中(Displaced Mark Word)。
2.然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针
3.如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程尝试使用自旋来获取锁



偏向锁、轻量级锁、重量级锁的优缺点



1.偏向锁是为了避免某个线程反复获得/释放同一把锁时的性能消耗，如果仍然是同个线程去获得这个锁，尝试偏向锁时会直接进入同步块，不需要再次获得锁。

2.而轻量级锁和自旋锁都是为了避免直接调用操作系统层面的互斥操作，因为挂起线程是一个很耗资源的操作。

为了尽量避免使用重量级锁（操作系统层面的互斥），首先会尝试轻量级锁，轻量级锁会尝试使用CAS操作来获得锁，如果轻量级锁获得失败，说明存在竞争。但是也许很快就能获得锁，就会尝试自旋锁，将线程做几个空循环，每次循环时都不断尝试获得锁。如果自旋锁也失败，那么只能升级成重量级锁。

3.可见偏向锁，轻量级锁，自旋锁都是乐观锁。

逃逸分析：



 

逃逸分析：通俗一点讲，当一个对象的指针被多个方法或线程引用时，我们称这个指针发生了逃逸，必须在JIT里完成

锁粗化：

如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展到整个操作序列的外部，这样就只需要加锁一次就够了

锁消除：

如果你定义的类的方法上有同步锁，但在运行时，却只有一个线程在访问，此时逃逸分析后的机器码，会去掉同步锁运行。

栈上分配：

分析找到未逃逸的变量，将变量类的实例化内存直接在栈里分配(无需进入堆)，分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。

从jdk1.6开始默认开启：
开启：  -XX:+DoEscapeAnalysis

关闭：  -XX:-DoEscapeAnalysis

3.1.Synchronized与ReentrantLock的区别



从字节码角度看实例synchronized方法、静态synchronized方法、synchronized代码块实现的不同







ReentrantLock =  一个AQS同步器(维护同步状态) + 一个AQS同步队列 + 多个Condition等待队列

3.2 ReentrantLock继承体系类图



ReentrantLock#lock()方法时序图





  
  
















































 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 













